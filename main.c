/*---------------------------------------------------------------*/
/* Micro GPS logger                            (C)ChaN, 2009     */
/*---------------------------------------------------------------*/

#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <string.h>
#include "ff.h"
#include "uart.h"
#include "suart.h"
#include "xitoa.h"
#include "stime.h"


/* This is the fuse settings for each operating mode. The fuse data will be
   included in the output hex file with program code. However some flash programmers
   may not support this sort of hex files. If it is the case, use these values to
   program the fuse bits.
*/
FUSES = {0xE2,0xDD,0xFF};


#define	IVT_SYNC	180			/* f_sync() interval [sec] */
#define	VI_LBT		3.6			/* Low battery threshold [volt] */
#define	VI_OBT		3.4			/* Out of threshold [volt] */

#define	BEEP_ON()		{TCCR0A=0b01010010; TCCR0B=0b01000011;}
#define	BEEP_OFF()		{TCCR0A=0b10100010;}
#define	LED_GREEN_ON()		{PORTC &= ~_BV(5);}
#define	LED_GREEN_OFF()		{PORTC |= _BV(5);}
#define	LED_RED_ON()		{PORTC &= ~_BV(4);}
#define	LED_RED_OFF()		{PORTC |= _BV(4);}
#define BACKUP_ON()		{PORTC |= _BV(2); DDRC |= _BV(2);}
#define BACKUP_OFF()	{DDRC &= ~_BV(2); PORTC &= ~_BV(2);}
#define POWER_ON()		{PORTD |= _BV(3);}
#define POWER_OFF()		{PORTD &= ~_BV(3);}
#define	BUTTON			bit_is_clear(PIND, 2)

#define	DLY_10MS(d)		{for (Timer = d; Timer; ) ;}



FATFS Fatfs;				/* File system object for each logical drive */
FIL File1;					/* File object */
char Line[100];				/* File/Console buffer */
char Str[20];

volatile BYTE MmcTmr[2];	/* 100Hz decrement timers */
volatile BYTE Timer;		/* 100Hz decrement timer */

volatile BYTE Stat;			/* Status flags and bit definitions */
#define	F_POW	0x80		/* Power */
#define	F_BTN	0x10		/* Button down for 1 sec */
#define	F_GPSOK	0x08		/* GPS data valid */
#define	F_SYNC	0x04		/* Sync request */
#define	F_LVD	0x01		/* Low battery */


struct tm *Ct;


ISR(INT0_vect)
{
	EIMSK = 0;
}



/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC1A                 */
/*---------------------------------------------------------*/


ISR(TIMER1_COMPA_vect)
{
	BYTE n;
	WORD ad;
	static WORD ivt_sync;
	static BYTE bt, led, lvt, ovt;


	n = Timer;
	if (n) Timer = --n;;
	n = MmcTmr[0];
	if (n) MmcTmr[0] = --n;;
	n = MmcTmr[1];
	if (n) MmcTmr[1] = --n;;

	if (++ivt_sync >= IVT_SYNC * 100) {
		ivt_sync = 0;
		Stat |= F_SYNC;
	}

	if (BUTTON) {
		if (++bt >= 100) 
			Stat |= F_BTN;
	} else {
		bt = 0;
	}
	
	
	ad = ADCL| (ADCH<<8);
	
	if (Stat & F_POW) {
		if (Stat & F_GPSOK) 
		{
			if (ad < (WORD)(VI_LBT/2/3.0*1024)) {
				if (++lvt >= 100)
				{
					LED_RED_ON();
					LED_GREEN_OFF();
				}
					
			} else {
				lvt = 0;
				LED_GREEN_ON();
				LED_RED_OFF();
			}
		}
		else if(++led & 0x20)
		{
			LED_GREEN_ON();
			LED_RED_OFF();
		}
		else {
			LED_GREEN_OFF();
			LED_RED_OFF();
		}
	} else {
		LED_GREEN_OFF();
		LED_RED_OFF();
	}
	
	if (ad < (WORD)(VI_OBT/2/3.0*1024)) {
		if (++ovt >= 100)
			Stat |= F_LVD;
	} else {
		ovt = 0;
	}
	
	ADMUX =  0b01000111;
	ADCSRA = 0b11000110;
}



/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/


DWORD get_fattime ()
{
	return	  ((DWORD)(Ct->tm_year - 1980) << 25)
			| ((DWORD)(Ct->tm_mon + 1) << 21)
			| ((DWORD)Ct->tm_mday << 16)
			| ((DWORD)Ct->tm_hour << 11)
			| ((DWORD)Ct->tm_min << 5)
			| ((DWORD)Ct->tm_sec >> 1);
}



/*----------------------------------------------------*/
/*  Get a line received from GPS module               */
/*----------------------------------------------------*/

int get_line (		/* 0:Button, -1:LVD, >0: Number of bytes received. */
	char *buff,
	UINT sz_buf
)
{
	char c;
	UINT i = 0;

	for (;;) {
		if (Stat & F_BTN) return 0;		/* Button detected */
		if (Stat & F_LVD) return -1;	/* Low battery is detected */
		c = uart_get();	/* Get a byte */
		if (!c) {		/* Sleep if no data arrived */
			set_sleep_mode(SLEEP_MODE_IDLE);
			sleep_mode();
			continue;
		}
		if (i == 0 && c != '$') continue;	/* Find start of line */
		buff[i++] = c;
		if (c == '\n') { buff[i] = 0; break; }	/* End of line */
		if (i >= sz_buf) { i = 0; continue; }	/* Buffer overflow (abort this line) */
	}

	return i;
}



/*--------------------------------------------------------------------------*/
/* Controls                                                                 */

void beep (BYTE len, BYTE cnt)
{
	while (cnt--) {
		BEEP_ON();
		DLY_10MS(len);
		BEEP_OFF();
		DLY_10MS(len);
	}
}



/* Compare sentence header string */
BYTE gp_comp (const char *str1, const prog_char *str2)
{
	char c;

	do {
		c = pgm_read_byte(str2++);
	} while (c && c == *str1++);
	return c;
}



/* Initialize GPS module */
static
void gp_init (void)
{
//	const prog_char *s =
//		PSTR("$PSRF106,21*0F\r\n");	// Select datum of WGS84 (for EM-406A)
//	char c;

//	while ((c = pgm_read_byte(s++)) != 0) uart_put(c);
}



/* Get a column item */
static
BYTE* gp_col (			/* Returns pointer to the item (returns a NULL when not found) */
	const char* buf,	/* Pointer to the sentence */
	BYTE col			/* Column number (0 is the 1st item) */
) {
	BYTE c;


	while (col) {
		do {
			c = *buf++;
			if (c <= ' ') return NULL;
		} while (c != ',');
		col--;
	}
	return (BYTE*)buf;
}




static
BYTE gp_val (
	const BYTE *db
)
{
	BYTE n, m;


	n = *db++ - '0';
	if (n >= 10) return 0;
	m = *db - '0';
	if (m >= 10) return 0;

	return n * 10 + m;
}




static
int gp_rmctime (	/* 1:An RMC sentence with valid flag is detected */
	const char *str
)
{
	const BYTE *p;
	struct tm tmc;
	time_t utc;


	if (gp_comp(str, PSTR("$GPRMC"))) return 0;	/* Not the RMC */

	p = gp_col(str, 2);		/* Get status */
	if (!p || *p != 'A') {
		Stat &= ~F_GPSOK;
		return 0;
	}

	p = gp_col(str, 1);		/* Get h:m:s */
	if (!p) return 0;
	tmc.tm_hour = gp_val(p);
	tmc.tm_min = gp_val(p+2);
	tmc.tm_sec = gp_val(p+4);

	p = gp_col(str, 9);		/* Get y:m:d */
	if (!p) return 0;
	tmc.tm_mday = gp_val(p);
	tmc.tm_mon = gp_val(p+2) - 1;
	tmc.tm_year = gp_val(p+4) + 100;

	utc = mktime(&tmc);				/* Check time validity */
	if (utc == -1) return 0;
	utc += 3600 * 9;				/* Create time in JST*/
	Ct = gmtime(&utc);

	Stat |= F_GPSOK;
	return 1;
}




static
void ioinit (void)
{
	PORTB = 0b11000011;	 	// Port B
	DDRB  = 0b00101100;

	PORTC = 0b111011;		// Port C
	DDRC  = 0b110000;

	PORTD = 0b00010100;		// Port D
	DDRD  = 0b11101000;

	OCR1A = F_CPU/8/100-1;		// Timer1: 100Hz interval (OC1A)
	TCCR1B = 0b00001010;
	TIMSK1 = _BV(OCIE1A);		// Enable TC1.oca interrupt

	OCR0A = F_CPU/64/4000/2-1;	// Timer0: 4kHz sound (OC0A)
	TCCR0A = 0b10100010;
	TCCR0B = 0b00000011;

	ACSR = _BV(ACD);		/* Disable analog comp */

	sei();
}



/*--------------------------------------------------------------------------*/
/* Power control */

void enter_sleep (
	int cause	/* 0:User, 1:Low battery, 2:Disk error */
)
{
	UCSR0B = 0;			/* Disable UART */

	SPCR = 0;			/* Disable SPI */
	PORTB &= ~_BV(2);	/* MMC CS = L */

	POWER_OFF();		/* MMC/GPS power off */

	Stat = 0;
	if (cause)
		beep(30, 3);	/* Three long beep (stopped due to error) */
	else
		beep(50, 1);	/* One long beep (stopped by button or low battery) */

	if (cause == 1)		/* Stop GPS backup if low battery */
		BACKUP_OFF();

	xprintf(PSTR("Enter sleep(%d)\r\n"), cause);

	do {
		/* Wait for button is released */
		while (BUTTON) DLY_10MS(5);

		/* Enter sleep mode */
		TIMSK1 = 0;				/* Disable TC1.oca interrupt */
		ADCSRA = 0;				/* Disable ADC */
		cli();
		EIFR = _BV(INTF0);		/* Enable INT0 */
		EIMSK = _BV(INT0);
		set_sleep_mode(SLEEP_MODE_PWR_DOWN);
		sleep_enable();
		MCUCR = _BV(BODS)|_BV(BODSE);	/* Disable BOD while sleep */
		MCUCR = _BV(BODS);
		sei();
		sleep_cpu();
		sleep_disable();

		/* Wakeup, delay 1sec */
		TIMSK1 = _BV(OCIE1A);	/* Enable TC1.oca interrupt */
		DLY_10MS(100);
	} while (!BUTTON);

	xputs(PSTR("Exit sleep\r\n"));

	Stat = F_POW;
	beep(5, 1);		/* Single beep. */

	BACKUP_ON();			/* GPS backup on */
	POWER_ON();				/* MMC/GPS power ON */
	DLY_10MS(10);			/* Delay 100ms */

	PORTB |= _BV(2);		/* MMC CS = H */
	SPCR = 0b01010000;		/* Initialize SPI port (Mode 0) */
	SPSR = 0b00000001;

	uart_init();

	/* Wait for button is released */
	while (BUTTON) DLY_10MS(5);

	Stat = F_POW;
}




/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
{
	BYTE log;
	UINT bw;
	int ls;


//	xfunc_out = (void(*)(uint8_t))xmit;	/* Debug output (PD7) */

	ioinit();

	ls = 0;
	for (;;) {
		enter_sleep(ls);
		DLY_10MS(10);			/* Delay 100ms */
		gp_init();				/* Initialize GPS module */

		f_mount(0, &Fatfs);
		if (f_open(&File1, ")(", 0) != FR_NO_FILE) {	/* Force disk mounted */
			xputs(PSTR("FS error\n"));
			ls = 2; continue;
		}
		xputs(PSTR("FS Ok\n"));

		log = 0;
		for (;;) {
			ls = get_line(Line, sizeof Line);
			if (ls <= 0) break;
			xprintf(PSTR("%s"), Line);

			if (!log) {
				log = gp_rmctime(Line);
				if (log) {	/* Initial wait for valid RMC sentence */
					xsprintf(Line, PSTR("%02u%02u%02u.LOG"), Ct->tm_year % 100, Ct->tm_mon + 1, Ct->tm_mday);
					xprintf(PSTR("Open %s\n"), Line);
					if (f_open(&File1, Line, FA_WRITE | FA_OPEN_ALWAYS)		/* Open log file */
						|| f_lseek(&File1, File1.fsize)) {					/* Append mode */
						log = 0; ls = 2; break;		/* Failed to open log file */
					}
					beep(5, 2);		/* Two beeps. Start logging. */
				}
			} else {
				gp_rmctime(Line);
				f_write(&File1, Line, ls, &bw);
				if ((int)bw != ls) {
					ls = 2; break;
				}
				if (Stat & F_SYNC) {
					if (f_sync(&File1)) {
						ls = 2; break;
					}
					cli(); Stat &= ~F_SYNC; sei();
				}
			}
		}

		if (log && f_close(&File1)) ls = 2;
	}

}


